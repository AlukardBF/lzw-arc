# Заметки по алгоритму

## Чтение битов

Считывать по байту, обрабатывать побитно

С оверхедом по памяти можно считывать побайтово и каждый бит записывать в

```rust
vec![u8]
```

Если не хватает байта, считывать еще один, и т.д.

## Запись битов

Сделать поток бит. т.е. каждый бит будет описываться как u8, например

```rust
vec![u8]
```

Отсюда сделать и конвертацию в байты, разбивая вектор по 8 бит и записывая получившиеся значения в файл. К последним битам, дописать нули до полных 8 бит.

Сравнение векторов

```rust
HashMap(vec![u8], BitVec)
где vec![u8] - строка,
BitVec - ее значение.
```

При считывании нового значения в словарь, BitVec просто последнее записанное число + 1 (лидирующие нулевые биты - отбрасывать),
например 256 = b00000001_00000000 == b1_00000000, итого 9 бит

## Алгоритм архивирования

1. В начале, словарь содержит все возможные единичные символы и ```P``` - пуст
2. ```C``` = следующий символ (байт) в потоке
3. Строка (набор байт) ```P+C``` уже присутствует в словаре?

   * Если да: ```P = P+C``` (расширить ```P``` символом ```C```)
   * Если нет:

      * Добавить выходной поток кодовым словом, что назначено ```P``` в словаре
      * Добавить строку ```P+C``` в словарь
      * ```P = C``` (```P``` теперь содержит только символ ```C```)

Заполнять выходной поток будем из промежуточного буфера. как только в нем накопится полный байт, добавляем его к потоку.
Если закончили чтение файла, добавляем в поток последний неполный байт, заполняя его до полного нулями.

## Алгоритм распаковки

1. В начале, словарь содержит все возможные единичные символы
2. ```cW``` = первое кодовое слово (по словарю)
3. Добавить ```string.cW``` в выходной поток
4. ```pW = cW```
5. ```cW``` = следующее кодовое слово
6. ```string.cW``` присутствует в словаре?

   Если да:

   * Добавить ```string.cW``` в выходной поток
   * ```P = string.pW```
   * ```C``` = первый символ в ```string.cW```
   * добавить строку ```P+C``` в словарь

   Если нет:

   * ```P = string.pW```
   * ```C``` = первый символ в ```string.pW```
   * добавить строку ```P+C``` в выходной поток и добавить в словарь (теперь ```P+C``` соответствует ```cW```)

7. Есть ли еще слова в потоке?

   * Если да, вернуться к шагу 4
   * Если нет, закончить выполнение


## Левые заметки

* Перед вставкой в переполненный словарь новой фразы на очередном шаге алгоритма удалять из словаря фразу, которая дольше всего не использовалась (LRU, Least Recently Used). Такая модификация иногда называется LZT.